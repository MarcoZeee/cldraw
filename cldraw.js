/*  CL Draw Probabilities
 *  Copyright (C) 2017-2018  Emmanuel Syrmoudis
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in all
 *  copies or substantial portions of the Software.

 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *  SOFTWARE.
 */

'use strict';

let computedProbabilities = {};
let fullCompatibilityMatrix;

// needed for export function
let seasonId;
let seasonLog = {};

// Web Worker
if (typeof(onmessage) !== 'undefined') {
	const INITIALIZE = 0;
	const GET_PROBABILITIES = 1;
	const GET_PROBABILITIES_PREVIEW = 2;
	const IMPORT_PROBABILITIES = 3;
	const EXPORT_PROBABILITIES = 4;
	const CLEAR_CACHE = 5;
	const GET_ID = 6;
	onmessage = function(e) {
		if (e.data[0] == INITIALIZE) {
			initialize(e.data[1], e.data[2]);
		} else if (e.data[0] == GET_PROBABILITIES) {
			postMessage(getProbabilities(e.data[1], e.data[2], e.data[3]));
		} else if (e.data[0] == GET_PROBABILITIES_PREVIEW) {
			postMessage(getProbabilitiesPreview(e.data[1], e.data[2], e.data[3]));
		} else if (e.data[0] == IMPORT_PROBABILITIES) {
			postMessage(importProbabilities(e.data[1]));
		} else if (e.data[0] == EXPORT_PROBABILITIES) {
			postMessage(exportProbabilities(e.data[1]));
		} else if (e.data[0] == CLEAR_CACHE) {
			clearCache();
		} else if (e.data[0] == GET_ID) {
			postMessage(getId());
		}
	}
}
// Node.js
if (typeof(exports) !== 'undefined') {
	exports.initialize = initialize;
	exports.getProbabilities = getProbabilities;
	exports.getProbabilitiesPreview = getProbabilitiesPreview;
	exports.importProbabilities = importProbabilities;
	exports.exportProbabilities = exportProbabilities;
	exports.clearCache = clearCache;
	exports.getId = getId;
}


function initialize(attr1, attr2) {
	if (attr2 == null && !Array.isArray(attr1[0][0])) {
		fullCompatibilityMatrix = attr1;
	} else {
		let attributes;
		if (attr2 != null) {
			attributes = [attr1, attr2];
		} else {
			attributes = attr1;
		}
		fullCompatibilityMatrix = [];
		// use attributes to build compatibility matrix
		for (let i = 0; i < attributes[0].length; i++) {
			let row = [];
			for (let j = 0; j < attributes[0].length; j++) {
				let matchable = true;
				for (let k = 0; k < attributes[0][i].length; k++) {
					if (attributes[0][i][k] == attributes[1][j][k] && attributes[0][i][k] != null
							&& attributes[1][j][k] != null && attributes[0][i][k] !== '' && attributes[1][j][k] !== '') {
						matchable = false;
					}
				}
				if (matchable) {
					row.push(true);
				} else {
					row.push(false);
				}
			}
			fullCompatibilityMatrix.push(row);
		}
	}

	seasonId = idToString(generateSortedId(fullCompatibilityMatrix)[0]);
	if (seasonLog[seasonId] == undefined) {
		seasonLog[seasonId] = new Set();
	}
}

function sortMatrix(matrix, rowOrder, columnOrder, inverse) {
	let result = [];
	for (let i = 0; i < rowOrder.length; i++) {
		result[i] = [];
	}
	for (let i = 0; i < rowOrder.length; i++) {
		for (let j = 0; j < rowOrder.length; j++) {
			if (!inverse) {
				result[i][j] = matrix[rowOrder[i]][columnOrder[j]];
			} else {
				result[rowOrder[i]][columnOrder[j]] = matrix[i][j];
			}
		}
	}
	return result;
}

// maps each row/column of the (boolean) compatibility matrix to
// an int in {0,...,(2^n)-1} (n := number of undrawn winners)
function generateUnsortedId(matrix, order, rowMode) {
	let id = [];
	for (let i = 0; i < matrix.length; i++) {
		let temp = 0;
		for (let j = 0; j < matrix.length; j++) {
			temp <<= 1;
			let entry;
			if (rowMode) {
				entry = matrix[i][j];
			} else {
				entry = matrix[j][i];
			}
			if (entry) {
				temp |= 1;
			}
		}
		id.push([temp, order[i]]);
	}
	return id;
}

// generates an identifier for the undrawn teams by
// alternatingly sorting columns and rows of compatibility matrix until ID
// generated by generateUnsortedId() does not change anymore;
// result includes two order arrays characterizing the permutation of 
// the original matrix to undo or redo the sorting
function generateSortedId(compatibilityMatrix) {
	let rowOrder = [];
	let columnOrder = [];
	for (let i = 0; i < compatibilityMatrix.length; i++) {
		rowOrder.push(i);
		columnOrder.push(i);
	}

	let matrix2 = compatibilityMatrix;
	let row = true;
	let sorted = [false, false];
	let id;
	// alternatingly sort rows and columns
	while (true) {
		let order;
		if (row) {
			order = rowOrder;
		} else {
			order = columnOrder;
		}
		let subId = generateUnsortedId(matrix2, order, row);
		sorted[row ? 0 : 1] = true;
		let maximum = -1;
		for (let i = 0; i < subId.length; i++) {
			if (subId[i][0] < maximum) {
				sorted[row ? 0 : 1] = false;
				break;
			} else {
				maximum = subId[i][0];
			}
		}
		if (!sorted[row ? 0 : 1]) {
			subId.sort(function(a,b) {
				return a[0] - b[0];
			});
			for (let i = 0; i < subId.length; i++) {
				order[i] = subId[i][1];
			}
		}
		if (row) {
			id = subId;
		}
		if (sorted[0] && sorted[1]) {
			break;
		}
		matrix2 = sortMatrix(compatibilityMatrix, rowOrder, columnOrder);
		row = !row;
	}
	let key = [];
	for (let i = 0; i < id.length; i++) {
		key[i] = id[i][0];
	}

	return [key, rowOrder, columnOrder];
}


function idToString(id) {
	let s = '';
	for (let i = 0; i < id.length; i++) {
		if (id[i] < 16) {
			s += '000' + (id[i]).toString(16);
		} else if (id[i] < 256) {
			s += '00' + (id[i]).toString(16);
		} else if (id[i] < 4096) {
			s += '0' + (id[i]).toString(16);
		} else {
			s += (id[i]).toString(16);
		}
	}
	return s;
}

// returns cached probabilities, null if dead end or undefined if not cached yet
function loadProbabilities(id) {
	let s = idToString(id[0]);
	seasonLog[seasonId].add(s);
	let temp = computedProbabilities[s];
	if (temp == null) {
		return temp;
	}
	let probabilities = sortMatrix(temp, id[1], id[2], true);
	return probabilities;
}

// caches probabilities
function saveProbabilities(id, probabilities) {
	let s = idToString(id[0]);
	computedProbabilities[s] = probabilities;
	if (probabilities == null) {
		computedProbabilities[s] = null;
	} else {
		let temp = sortMatrix(probabilities, id[1], id[2]);
		computedProbabilities[s] = temp;
	}
}


function computeProbabilities(compatibilityMatrix, unmatchedRunnerUp) {
	let id;
	if (unmatchedRunnerUp == undefined) {
		// use cached probabilities if existing
		id = generateSortedId(compatibilityMatrix);
		let cachedProbabilities = loadProbabilities(id);
		if (cachedProbabilities !== undefined) {
			return cachedProbabilities;
		}
	}

	let probabilities = [];
	let options = 0;
	let size = compatibilityMatrix.length;

	for (let i = 0; i < size; i++) {
		probabilities[i] = [];
		for (let j = 0; j < size; j++) {
			probabilities[i][j] = 0;
		}
	}

	// if the same number of winners and runners-up has been drawn
	if (unmatchedRunnerUp == undefined) {
		for (let i = 0; i < size; i++) {
			options++;
			// temporarily draw runner-up i and compute the resulting probabilities
			let conditionalProbabilities = computeProbabilities(compatibilityMatrix, i);
			if (conditionalProbabilities === null) {
				options--;
			} else {
				for (let j = 0; j < size; j++) {
					for (let k = 0; k < size; k++) {
						probabilities[j][k] += conditionalProbabilities[j][k];
					}
				}
			}
		}
		// return null if the current draw is a dead end
		if (options == 0 && size > 0) {
			probabilities = null;
		}

	// if an opponent for team 'unmatchedRunnerUp' is to be drawn next
	} else {
		for (let i = 0; i < size; i++) {
			if (compatibilityMatrix[i][unmatchedRunnerUp]) {
				options++;
				// temporarily match unmatchedRunnerUp with winner i and compute the resulting probabilities
				let subMatrix = [];
				for (let j = 0; j < size; j++) {
					if (j != i) {
						let row = [];
						for (let k = 0; k < size; k++) {
							if (k != unmatchedRunnerUp) {
								row.push(compatibilityMatrix[j][k]);
							}
						}
						subMatrix.push(row);
					}
				}
				let conditionalProbabilities = computeProbabilities(subMatrix);
				if (conditionalProbabilities === null) {
					options--;
				} else {
					for (let j = 0; j < size; j++) {
						for (let k = 0; k < size; k++) {
							if (j < i) {
								if (k < unmatchedRunnerUp) {
									probabilities[j][k] += conditionalProbabilities[j][k];
								}
								if (k > unmatchedRunnerUp) {
									probabilities[j][k] += conditionalProbabilities[j][k - 1];
								}
							} else if (j > i) {
								if (k < unmatchedRunnerUp) {
									probabilities[j][k] += conditionalProbabilities[j - 1][k];
								}
								if (k > unmatchedRunnerUp) {
									probabilities[j][k] += conditionalProbabilities[j - 1][k - 1];
								}
							}
						}
					}
					probabilities[i][unmatchedRunnerUp] += 1;
				}
			}
		}
		// return null if the current draw is a dead end
		if (options == 0) {
			probabilities = null;
		}
	}

	if (options != 0) {
		for (let i = 0; i < size; i++) {
			for (let j = 0; j < size; j++) {
				probabilities[i][j] /= options;
			}
		}
	}

	if (unmatchedRunnerUp == undefined) {
		saveProbabilities(id, probabilities);
	}

	return probabilities;
}


function getProbabilities(drawnW, drawnR, unmatchedRunnerUp) {
	if (drawnW == null) {
		return computeProbabilities(fullCompatibilityMatrix);
	}
	let compatibilityMatrix = [];
	for (let i = 0; i < fullCompatibilityMatrix.length; i++) {
		if (!drawnW[i]) {
			let row = [];
			for (let j = 0; j < fullCompatibilityMatrix.length; j++) {
				if (!drawnR[j] || j == unmatchedRunnerUp) {
					if (fullCompatibilityMatrix[i][j]) {
						row.push(true);
					} else {
						row.push(false);
					}
				}
			}
			compatibilityMatrix.push(row);
		}
	}
	for (let i = unmatchedRunnerUp - 1; i >= 0; i--) {
		if (drawnR[i]) {
			unmatchedRunnerUp--;
		}
	}
	return computeProbabilities(compatibilityMatrix, unmatchedRunnerUp);
}


function getProbabilitiesPreview(drawnW, drawnR, possibleOpponent) {
	let probabilities = [];
	let num = 0;
	for (let i = 0; i < drawnR.length; i++) {
		if (drawnR[i]) {
			num++;
		}
		if (drawnW[i]) {
			num--;
		}
	}
	if (num == 0) {
		for (let i = 0; i < drawnR.length; i++) {
			if (possibleOpponent[i]) {
				drawnR[i] = true;
				probabilities[i] = getProbabilities(drawnW, drawnR, i);
				drawnR[i] = false;
			}
		}
	} else {
		for (let i = 0; i < drawnR.length; i++) {
			if (possibleOpponent[i]) {
				drawnW[i] = true;
				probabilities[i] = getProbabilities(drawnW, drawnR);
				drawnW[i] = false;
			}
		}
	}
	return probabilities;
}


function exportProbabilities(limit) {
	if (limit == undefined) {
		limit = 0;
	}
	let croppedProbabilities = {};
	for (let id of seasonLog[seasonId]) {
		// only consider probabilities for cases where >= 'limit' teams are in the winners pot
		if (id.length >= limit * 4) {
			croppedProbabilities[id] = computedProbabilities[id];
		}
	}
	return croppedProbabilities;
}


function importProbabilities(probabilities) {
	for (let id in probabilities) {
		computedProbabilities[id] = probabilities[id];
	}
}


function clearCache() {
	computedProbabilities = {};
}


function getId() {
	return [seasonId, computedProbabilities[seasonId] !== undefined];
}
